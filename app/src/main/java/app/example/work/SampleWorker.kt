package app.example.work

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import app.example.di.AppWorkerFactory
import app.example.di.AppWorkerFactory.WorkerInstanceFactory
import app.example.di.WorkerKey
import dev.zacsweers.metro.AppScope
import dev.zacsweers.metro.Assisted
import dev.zacsweers.metro.AssistedFactory
import dev.zacsweers.metro.AssistedInject
import dev.zacsweers.metro.ContributesIntoMap
import dev.zacsweers.metro.binding
import kotlinx.coroutines.delay
import kotlin.time.Duration.Companion.seconds

/**
 * A sample Worker that demonstrates WorkManager integration with Metro DI.
 *
 * This Worker showcases Metro's assisted injection feature, which allows mixing
 * runtime parameters (like [WorkerParameters]) with injected dependencies.
 *
 * Key Metro features demonstrated:
 * - [AssistedInject]: Marks this class for assisted constructor injection
 * - [Assisted]: Marks parameters that are provided at runtime (not from DI graph)
 * - [WorkerKey]: Map key annotation for multibinding Workers
 * - [ContributesIntoMap]: Contributes this Worker's factory to the multibinding map
 * - [AssistedFactory]: Generates a factory for creating this Worker
 *
 * How it works:
 * 1. WorkManager creates workers via [AppWorkerFactory]
 * 2. [AppWorkerFactory] looks up the Worker class in the factory map
 * 3. The factory is generated by [@AssistedFactory][AssistedFactory] annotation
 * 4. Metro injects all dependencies except [@Assisted][Assisted] parameters
 * 5. Runtime parameters (Context, WorkerParameters) are passed at creation time
 *
 * See https://zacsweers.github.io/metro/latest/injection-types/#assisted-injection for assisted injection.
 * See https://zacsweers.github.io/metro/latest/bindings/#multibindings for multibindings.
 * See [AppWorkerFactory] for the factory implementation.
 */
@AssistedInject
class SampleWorker(
    context: Context,
    @Assisted params: WorkerParameters,
) : CoroutineWorker(context, params) {
    companion object {
        const val KEY_WORK_NAME = "workName"
    }

    override suspend fun doWork(): Result {
        val workName = inputData.getString(KEY_WORK_NAME) ?: "unknown"
        Log.d("SampleWorker", "Sample doWork running: $workName")

        // Simulate some work
        delay(5.seconds)

        return Result.success()
    }

    @WorkerKey(SampleWorker::class)
    @ContributesIntoMap(
        AppScope::class,
        binding = binding<WorkerInstanceFactory<*>>(),
    )
    @AssistedFactory
    abstract class Factory : WorkerInstanceFactory<SampleWorker>
}
